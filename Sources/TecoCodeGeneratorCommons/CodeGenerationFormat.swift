//===----------------------------------------------------------------------===//
//
// This source file is part of the Teco open source project.
//
// Copyright (c) 2022-2023 the Teco project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Teco project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//
//
// This source file was part of the Swift.org open source project
//
// Copyright (c) 2014 - 2022 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//

#if compiler(>=6.0)
public import SwiftBasicFormat
public import SwiftSyntax
#else
import SwiftBasicFormat
import SwiftSyntax
#endif

/// A format style for files generated by TecoCodeGenerator.
public class CodeGenerationFormat: BasicFormat {
    // MARK: - Additional newline between members

    public override func visit(_ node: MemberBlockItemSyntax) -> MemberBlockItemSyntax {
        if node != node.parent?.children(viewMode: .sourceAccurate).first?.as(MemberBlockItemSyntax.self),
           !node.decl.is(EnumCaseDeclSyntax.self) {
            return super.visit(node).ensuringTwoLeadingNewlines()
        } else {
            return super.visit(node)
        }
    }

    public override func visit(_ node: CodeBlockItemSyntax) -> CodeBlockItemSyntax {
        if node.parent?.parent?.is(SourceFileSyntax.self) == true, !shouldBeSeparatedByTwoNewlines(node: node) {
            return super.visit(node).ensuringTwoLeadingNewlines()
        } else {
            return super.visit(node)
        }
    }

    // MARK: - Expand list to multiple lines

    public override func visit(_ node: ArrayElementListSyntax) -> ArrayElementListSyntax {
        let children = node.children(viewMode: .all)
        if children.count > 5 {
            return ArrayElementListSyntax(formatChildrenSeparatedByNewline(children: children))
        } else {
            return super.visit(node)
        }
    }

    public override func visit(_ node: DictionaryElementListSyntax) -> DictionaryElementListSyntax {
        let children = node.children(viewMode: .all)
        if children.count > 3 {
            return DictionaryElementListSyntax(formatChildrenSeparatedByNewline(children: children))
        } else {
            return super.visit(node)
        }
    }

    public override func visit(_ node: LabeledExprListSyntax) -> LabeledExprListSyntax {
        let children = node.children(viewMode: .all)
        if children.contains(where: { $0.trimmedDescription.contains(where: \.isNewline) }) {
            return LabeledExprListSyntax(formatChildrenSeparatedByNewline(children: children))
        } else {
            return super.visit(node)
        }
    }

    // MARK: - Private helpers

    private func shouldBeSeparatedByTwoNewlines(node: CodeBlockItemSyntax) -> Bool {
        return node.parent?.as(CodeBlockItemListSyntax.self)?.first == node || node.item.is(ImportDeclSyntax.self)
    }

    private func formatChildrenSeparatedByNewline<SyntaxType: SyntaxProtocol>(children: SyntaxChildren) -> [SyntaxType] {
        var formattedChildren = children.map {
            self.rewrite($0).trimmed.as(SyntaxType.self)!
        }
        formattedChildren = formattedChildren.map {
            $0.with(\.leadingTrivia, .newline + currentIndentationLevel + $0.leadingTrivia)
        }
        if let lastChild = formattedChildren.last,
           let closingToken = lastChild.parent?.nextToken(viewMode: .sourceAccurate),
           !closingToken.leadingTrivia.contains(where: \.isNewline)
        {
            formattedChildren.removeLast()
            formattedChildren.append(
                lastChild.with(\.trailingTrivia, .newline + .init(pieces: currentIndentationLevel.dropLast()))
            )
        }
        return formattedChildren
    }
}

private extension SyntaxProtocol {
    func ensuringTwoLeadingNewlines() -> Self {
        if self.leadingTrivia.first?.isNewline == true {
            return self.with(\.leadingTrivia, .newline + leadingTrivia)
        } else {
            return self.with(\.leadingTrivia, .newlines(2) + leadingTrivia)
        }
    }
}
